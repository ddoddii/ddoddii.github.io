+++
author = "Soeun"
title = "랜덤값에 의한 비즈니스 로직 테스트하기"
date = "2023-11-04"
description = "자동차 경주 리팩토링"
categories = [
    "CS"
]
tags = [
    "Clean Code"
]
image = ""
slug = "testing-random-values"
+++

## 👎🏻 냄새나는 코드

만약, 랜덤 숫자로 인해 로직이 생긴다고 하자. 예를 들어, 랜덤값이 4 이상이면 자동차가 1 전진하는 규칙이 있다고 하자.

테스트 하기 나쁜 💩냄새나는 코드💩 의 예시를 보자. 

```java
public class Car{
	private final CarName carName;  
	private final CarPosition carPosition;
	
	public Car(String name) {  
	    this.carName = new CarName(name);  
	    this.carPosition = new CarPosition();  
	}
	public void moveByCondition() {  
	    if (moveRule.shouldMove()) {  
	        carPosition.advancePosition();  
	    }  
	}
}
```

```java
public class MoveStrategy{
	public boolean shouldMove() {  
	    randomNumber = randomNumberGenerator.getRandomNumber();  
	    return randomNumber >= MOVE_CONDITION;  
	}
}
```

위는 moveByCondition 메서드가 shouldMove 에 의존하고 있다. shouldMove 는 random number 에 따라서 true/false 값을 반환되기 때문에 쉽게 테스트하기 힘들다. 즉, 테스트하기 어려운 냄새나는 코드이다. 이것을 테스트 가능한 코드로 리팩토링 해보자. 

## 👍 Strategy interface 생성

<span style="background:#fff88f">Strategy 인터페이스를 생성</span>하고, 실제 프로덕션 코드에는 랜덤값에 따라 결정되는 RandomMoveStrategy, 테스트 코드에는 내가 고정된 값으로 테스트할 수 있는 FixedMovedStrategy 를 주입하는 것이다.  인터페이스를 주입받으면 실제 전략과 자동차 사이의 결합도가 떨어진다. Strategy 를 구현하는 실제 전략들을 무조건 shouldMove() 메서드를 구현해야 한다. 

```java
public interface Strategy {  
    int MOVE_CONDITION = 4;  
    boolean shouldMove();  
}
```

아래는 실제 프로덕션 코드에서 사용하는 **RandomMoveStrategy** 이다. 랜덤값에 따라 shouldMove 가 True/False 가 반환된다. 
```java
public class RandomMoveStrategy implements Strategy {  
    @Override  
    public boolean shouldMove() {  
        return RandomNumberGenerator.getRandomNumber() >= MOVE_CONDITION;  
    }  
}
```

아래는 테스트 코드에서 사용할 **FixedMoveStrategy** 이다. 내가 주입하는 값에 따라 Treu/False 가 반환된다. 
```java
public class FixedMoveStrategy implements Strategy {  
  
    private int num;  
    public FixedMoveStrategy(int num){  
        this.num = num;  
    }  
    @Override  
    public boolean shouldMove() {  
        return num >= MOVE_CONDITION;  
    }  
}
```

그럼 Car 객체를 다시 구현해보자. 생성자에 Strategy 인터페이스 를 받고 있다. Car 의 입장에서는 이게 실제로 RandomMoveStrategy 인지, FixedMoveStrategy 인지 알지 못한다. 

```java
public class Car {  
    private final CarName carName;  
    private final CarPosition carPosition;  
    private final Strategy strategy;  
  
    public Car(String name, Strategy strategy) {  
        this.carName = new CarName(name);  
        this.carPosition = new CarPosition();  
        this.strategy = strategy;  
    }  
  
    public void moveByCondition() {  
        if (strategy.shouldMove()){  
            carPosition.advancePosition();  
        }  
    }
}
```

이제 테스트코드를 다시 작성해보자. Car 객체를 생성할 때 테스트 코드 용도로 만들었던 FixedMoveStrategy 를 주입하면 된다. 이렇게 되면 주어진 숫자에 따라 moveByCondition() 메서드가 잘 작동하는지 테스트 할 수 있다 ! 

```java
@Test  
@DisplayName("4 미만의 수가 주어질 때 자동차 움직임 테스트")  
void car_test_when_under_4(){  
    Car car = new Car("mycar",new FixedMoveStrategy(3));  
    car.moveByCondition();  
    Assertions.assertThat(car.getPosition()).isEqualTo(0);  
}  
  
@Test  
@DisplayName("4 이상의 수가 주어질 때 자동차 움직임 테스트")  
void car_test_when_over_4(){  
    Car car = new Car("mycar",new FixedMoveStrategy(4));  
    car.moveByCondition();  
    Assertions.assertThat(car.getPosition()).isEqualTo(1);  
}
```

이것은 디자인패턴 중 하나인 <span style="background:#fff88f">**전략패턴**</span> 을 활용한 것이다. Car 객체가 인터페이스에 의존하게 만들어서, 유연성을 높일 수 있었다. 


## Reference
https://tecoble.techcourse.co.kr/post/2020-05-17-appropriate_method_for_test_by_interface/