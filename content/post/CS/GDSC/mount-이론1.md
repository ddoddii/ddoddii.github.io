+++
author = "Soeun"
title = "GDSC mount - BackEnd 탐구(1)"
date = "2023-08-31"
description = "GDSC Yonsei - BackEnd Mount"
categories = [
    "CS"
]
tags = [
    "GDSC",
    "BackEnd"
]
image = "https://github.com/ddoddii/DSL-23-1-modeling-AuToeic/assets/95014836/d9821a03-2b61-4b89-b5c4-cc409f04fa23"
+++
## GDSC Yonsei
9월부터 **GDSC** 에서 본격적으로 활동하기에 앞서 백엔드 부분을 더 깊이 탐구하고자 Mount 과정을 진행하고 있다. 아래는 주어진 여러 질문들이고 공부하며 답변을 작성하였다. 
## BE 이론

### VM과 컨테이너의 차이가 무엇인가요? (Docker, Python VirtualEnv 는 어디에 속하나요?)

- <span style="background-color: #EBFFDA">**VM과 컨테이너가 필요한 이유**</span>
  - 하나의 어플리케이션을 실행시키고자 할 때, 이것은 OS와 라이브러리에 의존한다. 그러므로 하나의 컴퓨터에서 성격이 다른 (OS, 라이브러리 버전이 다른) 소프트웨어를 실행하기 어렵다.
  - 컨테이너 및 가상 머신은 어플리케이션을 IT 인프라 리소스(각 로컬 컴퓨터마다 설치되어 있는 OS, 라이브러리 버전 등)로부터 독립적으로 만드는 기술이다. 컨테이너와 가상 머신을 사용하면 여러 환경에서 독립적으로 실행할 수 있도록 어플리케이션을 완전히 격리할 수 있다. 

    ![image](https://github.com/ddoddii/ddoddii.github.io/assets/95014836/146dc23b-a68a-4bcd-a5a2-24297751eb6f)

- <span style="background-color: #EBFFDA">**VM : Virtual Machine (가상머신)**</span>

   - 가상머신은 호스트 운영체제 위에 가상의 하드웨어를 서비스하는 하이퍼바이저 같은 가상머신을 관리하는 소프트웨어가 돌아가고, 해당 소프트웨어가 제공하는 가상의 하드웨어에 게스트 운영체제를 설치해서 사용한다. 
   - VM방식은 어플리케이션이 돌아갈 수 있는 OS 환경이 포함된다. 그렇기 때문에 어플리케이션을 실행하기 위해서는 VM을 띄워 자원을 할당한 다음, OS를 부팅한 후 어플리케이션을 구동할 수 있기 때문에 시간이 오래 걸린다. 
   - 가상머신의 단점
     1. 완전한 OS가 설치되기 때문에 대량의 메모리가 필요하다. 
        - 독립적인 환경을 만들 때마다 불필요한 OS를 만드는 작업을 계속해야 해서, 확장성이 떨어진다. 또한 메모리나 자원을 유동적으로 관리하는 것이 아니라 처음부터 정해놓고 실행하기 때문에 비효율적이다. 
     2. CPU 성능 확보에 대한 문제가 있다.
          - 서로 다른 어플리케이션이 CPU 자원에 대한 요청을 할 때, CPU 자원에 대한 경쟁이 발생한다. 하나의 VM내에서 어떤 어플리케이션의 우선순위가 높다고 해도, 이 VM의 OS가 전체 VM OS 상에서 우선순위가 낮다면, 이 어플리케이션은 물리적인 CPU를 많이 할당받지 못할 수 도 있다. VM에서는 이러한 문제를 해결하기 위해 CPU같은 물리적인 자원을 특정 게스트 OS에 전담배치하는 Dedicate 서비스를 제공한다. 
     3. 시스템 운영에 대한 통합적인 지식이 필요하다.
          - VM에서는 새로운 시스템을 구축하는 개념이기 때문에 시스템 운영에 대한 지식도 필요하다.
- <span style="background-color: #EBFFDA">**컨테이너**</span>
  - 각 어플리케이션이 모두 하나의 OS 커널*을 공유하여 사용한다. 각 컨테이너마다 OS가 필요없으므로 더 가볍고, 크기고 작아 복제와 배포에 간편하다. 여기서 커널이란, 운영 체제의 핵심으로 하드웨어의 자원(CPU, Memory, Devices)을 각 프로세스에 사용할 수 있도록 나눠주고, 프로세스 및 메모리 제어 등 시스템의 모든 것을 통제하는 것이다. 
  - 불필요한 OS 만드는 작업 및 Infra 를 독립적으로 나눌 필요가 없어서 확장성이 좋고 빠르다. 
  - 흔히 **도커 컨테이너**라고 말하는데, 여기서 도커는 컨테이너 서비스를 지원하기 위한 플랫폼이다. 도커를 사용하면 인프라에서 어플리케이션을 분리하여 컨테이너로 추상화*시켜 소프트웨어를 빠르게 제공할 수 있다. 
  - 추상화란, 복잡한 자료, 모듈, 시스템 등으로부터 핵심적인 개념 또는 기능을 간추려 내는 것이다. 즉 추상화는 복잡한 것을 우리가 이해하기 쉽고, 연상하기 쉽고, 공유하기 쉽도록 하는 것이다. 컨테이너는 표준화된 소프트웨어 유닛을 추상화한다. 그 추상화에 들어가는 요소들은 코드, 런타임, 셋팅, 라이브러리이다. 
- <span style="background-color: #EBFFDA">**Python VirtualEnv vs. Docker**</span>
  -  **도커**는 컨테이너를 이용하여 어플리케이션을 쉽게 생성(create), 전개(deploy), 실행(run)할 수 있도록 설계된 툴이다. 쉽게 말해서 다른 운영체제를 가신 컴퓨터에서도 동일한 실행환경을 만들어주는 툴이다. 
  - **파이썬 가상환경**은 python 프로젝트의 종속성 구조만 보는 반면, **도커 컨테이너**는 운영체제의 이미지 전체가 포함되어 있다. 
  - **가상 환경**은 오로지 python의 의존성을 캡슐화 하지만 **도커**는 컨테이너는 OS 전체를 캡슐화한다.
  - 이 때문에 virtualenv를 통해서는 파이썬 버전은 쉽게 바꿀 수 있었지만 결국 호스트 OS 내부에 갇혀있어야 했다. 하지만 도커 이미지를 사용하면 OS를 교체해버릴 수 있다. Ubuntu, Debian, Alpine, Windows Server Core에도 설치하고 실행할 수 있다.
  - 도커에서는 image 라는 개념을 통해 내 로컬 컴퓨터에 직접 설치하는 대신 이미지를 가져와서 실행할 수 있다. 내가 nodejs 를 기반으로 프로젝트를 만들고 싶으면 도커 컨테이너를 만들어서 dockerhub 에서 Nodejs 이미지를 pull 하면 된다. 
  - 그냥 내 로컬 컴퓨터에서 프로젝트를 실행한다고 해보자. A 프로젝트는 pythorch, transformers, pandas 등을 사용하고, B 프로젝트는 tensorflow, fastapi 등을 이용한다고 하자. 이따는 그냥 venv 2가지를 만들어서 파이썬 버전과 맞는 라이브러리들을 관리하면 된다.
  - 하지만 나는 맥 환경에서 프로젝트를 빌드 했는데, 이것을 내 친구의 윈도우 컴퓨터에서 문제없이 실행하고 싶다면 ? 내 로컬 컴퓨터에서 도커 이미지로 만든 다음, 이 이미지를 도커 컨테이너로 실행하면 OS 에 상관없이 실행할 수 있다. 

### 토큰 기반 인증과 세션 기반 인증을 비교해주세요. 본인이라면 어떤 방식을 사용할 것 같나요?
- <span style="background-color: #EBFFDA">**인증(Authorization)과 인가(Authorization)은 무엇인가?**</span>
  - **인증**을 쉽게 말하자면 로그인이다. 클라이언트가 자기자신이라고 주장하고 있는 사용자가 맞는지를 검증하는 과정이다. 로그인 화면에서 유저가 아이디와 비밀번호를 입력하면, 서버에서는 내가 진짜로 유저가 맞는지 확인한다. 
  - **인가**는 인증 작업 이후에 행해지는 작업으로, 인증된 사용자에 대한 자원에 대한 접근 확인 절차를 의미한다. 각 유저마다 접근 권한이 다를 수 있다. 관리자는 모든 게시판에 접근가능하지만, 일반 유저는 자신이 쓴 게시판에만 접근 가능하다고 하자. 이때 관리자와 일반 유저에게 각각 인증된 자원에 접근 절차를 확인하는 것이 인가이다. 
  ![image](https://github.com/ddoddii/ddoddii.github.io/assets/95014836/eb3544d9-9ae2-400f-a807-f71575dacd55)

- <span style="background-color: #EBFFDA">**세션 기반 인증**</span>
  - HTTP는 Stateless 하다. 즉, 서버에서는 사용자가 날린 request 에 대한 정보를 기억하고 있지 않는다. 따라서 사용자 인증을 할 때, 서버 측에서 사용자들의 정보를 기억하고 있어야 한다. 사용자들이 로그인을 하면, 서버는 **세션***을 출력한다. 
    - 세션(Session) : 컴퓨터 공학에서 '정보 간의 정보 교환'을 의미하며, 서버에 '로그인이 되어있음'이 지속 되는 상태도 '세션'이라고 한다.
  - 세션 기반 인증을 하기 위해서는 Session 과 Cookie 가 사용되며, 아래와 같이 진행된다.

    ![image](https://github.com/ddoddii/ddoddii.github.io/assets/95014836/9a1c428b-f4a7-4cb3-82b2-71b40138b8b4)

  - 절차
    1. 유저가 서버에 로그인 정보를 보낸다.
    2. 서버의 세션 저장소에 사용자 인증 정보를 저장한다.
    3. 유저에게는 Session ID 를 발급한다. 이때 발급된 Session ID는 유저 브라우저 상에 Cookie 형태로 저장된다.
    4. 유저는 이후 서버에 request 를 보낼 때마다 HTTP Cookie header 에 Session ID 를 함께 서버로 전송한다.
    5. 서버는 Session ID를 저장된 사용자 인증 정보와 비교한다.
    6. Session ID 와 사용자 세션 정보가 일치하면 success response 를 보낸다.
    
- <span style="background-color: #EBFFDA">**토큰 기반 인증**</span>
  - 토큰 기반 인증은 인증 정보를 클라이언트가 직접 들고 있는 방식이다. 클라이언트의 정보는 JWT(JSON Web Token)으로 변환되어 저장된다. 쉽게 말하자면 클라이언트 정보를 암호화 하는 기술을 서버 쪽에서 가지고 있고, 사용자가 자기 정보를 보내면 그 기술로 암호화해서 클라이언트에게 다시 전송해준다. 그 암호를 풀 수 있는 기술도 서버만 가지고 있다.

  ![스크린샷 2023-09-03 오후 4 19 08](https://github.com/ddoddii/ddoddii.github.io/assets/95014836/a932600e-5e71-4529-8117-dc43b8d6b943)

  - 절차
    1. 클라이언트가 인증 정보를 서버에게 보낸다.
    2. 클라이언트의 인증 정보를 사용해서 JWT 를 만든다.
    3. 만든 JWT 를 다시 클라이언트에게 보낸다.
    4. 클라이언트는 JWT 를 로컬 저장소에 저장한다.
    5. 클라이언트가 request를 보낼때 가지고 있는 JWT를 HTTP 의 Authorization 헤더에 실어서 보낸다.
    6. 서버는 JWT가 진짜인지 확인하고, 맞으면 success response 를 보낸다.

- <span style="background-color: #EBFFDA">**세션 기반 인증 vs 토큰 기반 인증**</span>
  - 사이즈
    - 세션 기반 인증은 Cookie 헤더에 Session ID만 보내므로 트래픽을 적게 사용한다. 하지만 토큰 기반 인증을 할 때 JWT는 사이즈가 상대적으로 더 크다. 따라서 더 많은 트래픽을 사용한다.
  - 안정성과 보안문제
    - 세션은 모든 인증 정보가 서버의 세션 저장소에 저장된다. 따라서 클라이언트의 컴퓨터가 해킹 당해도 로그인 정보는 안전한다.
    - 토큰 기반 인증은 클라이언트가 JWT를 가지고 있기 때문에, 클라이언트의 컴퓨터가 해킹당해서 JWT를 뺴앗기게 되면 속수무책이다. 
  - 확장성
    - 여기까지만 보면 세션 인증 기반을 사용하는 것이 장점이 더 많아 보인다. 하지만 현재 거의 모든 웹 어플리케이션이 토큰 기반 인증을 사용하고 있다고 한다. 그것의 이유가 뛰어난 확장성이다.
    - 세션 기반 인증은 서버가 사용자 데이터를 저장하고 있으므로, 유저는 자기 정보가 저장된 딱 그 서버 한대와만 소통해야 한다. 하지만 수평 확장을 적용하는 웹 어플리케이션 특성상, 이것은 매우 불리하다. 
    - 토큰 기반 인증은 클라이언트에게 정보가 있으므로 어느 서버와 소통해도 인증이 가능하다. 따라서 토큰 기반 인증은 HTTP 의 stateless 한 특성을 그대로 사용할 수 있고, 높은 확장성을 가진다.

- <span style="background-color: #EBFFDA">**나라면 어떤 인증 방식을 사용할 것인가?**</span>
  - 위 두가지의 특성을 보아, 나는 은행 로그인 정보와 같이 보안이 정말 중요한 데이터를 다룬다면 세션 기반 인증을 사용할 것 같다. 아무래도 JWT는 브라우저에 그대로 노출되어 있으므로 노출의 위험이 크다. 만약 JWT 토큰을 쓴다면 보안을 2중화 (핸드폰 인증을 거친다던지..) 해서 사용하면 좋을 듯 하다.

### 동기와 비동기, 블로킹과 논블로킹의 차이에 대해 설명해주세요. 또한, 각각을 사용한 예시 또한 설명해주세요. 

- <span style="background-color: #EBFFDA">**블로킹 vs 논블로킹**</span>
  - 알아야 할 키워드 
    - 제어권 : 함수 내용을 실행시킬 수 있는 권리 
    - 결과값 : 함수의 리턴값
  - 블로킹(Blocking)
    - 함수를 호출할 때 제어권도 함께 넘겨주고 작업이 끝난 후 돌려받는 것이다. 즉, 호출된 함수의 작업이 종료될 때까지 호출하는 함수는 다른 작업을 진행할 수 없다.
    - 호출된 함수는 모든 실행을 마치고 결과값을 리턴해준다.
  - 논블로킹(Non-Blocking)
    - 논블로킹도 마찬가지로 함수를 호출할 때 제어권을 넘겨주긴 하지만, 곧바로 돌려받는다. 즉 함수A의 작업이 끝나지 않아도 부모함수(호출한 함수)는 제어권을 넘겨받고 다음 함수B를 실행할 수 있다. 
  - 블로킹 vs 논블로킹
    - 이 둘을 구분짓는 기준은 **'호출된 함수가 제어권을 호출한 함수에게 언제 돌려주는지'** 이다. 

- <span style="background-color: #EBFFDA">**동기 vs 비동기**</span>
  - 동기(syschronous) 방식
    - '시간을 맞추는' 방식이다.
    - 함수가 두개 이상 존재할 때, 동기방식은 함수들의 작업을 동시에 시작하거나, 끝나는 타이밍을 맞추거나, 하나가 끝나고 다른 하나를 차례로 실행하는 방식이다. 
    - 동기는 제어권과 결과값을 동시에 반환한다. 부모함수가 자식함수A를 호출할 때, 제어권을 넘겨준다. 자식함수A의 실행이 끝나고 결과값을 리턴할 때, 제어권도 같이 반환한다. 그러면 부모함수는 다른 자식함수B를 실행할 수 있다.

  - 비동기(Asynchoronous) 방식
    - 비동기는 동기가 아닌 방식이다. 즉 두 함수가 서로 언제 시작하고, 언제 끝나는지 전혀 신경쓰지 않는다. 
    - 부모함수는 여러 자식함수A,B,C 를 호출하면, 함수A,B,C가 각각 알아서 완료되었는지 여부를 알려준다. 
    - 비동기는 제어권과 결과값을 다른 시점에 따로따로 반환한다.

  - 동기 vs 비동기
    - 둘을 구분짓는 기준은 여러개의 함수들이 **'시간을 맞춰서 실행하느냐'** 이다.
    - **동기방식**은 설계가 직관적이고 간단하지만, 하나의 요청이 처리될 때까지 아무것도 못하고 기다려야 한다는 단점이 있다.
    - **비동기 방식**은 동기보다는 복잡하고 속도가 느리지만, 하나의 요청이 처리되는 동안 다른 작업도 할 수 있으므로 자원을 효율적으로 사용할 수 있다는 장점이 있다.

- <span style="background-color: #EBFFDA">**예시**</span>

  ![image](https://github.com/ddoddii/ddoddii.github.io/assets/95014836/9aa2e561-e2b5-4dbb-9fa1-81b31aceea6f)
  - Javascript 에서 비동기 처리 방식
    - Javascript 는 싱글 스레드 기반으로 프로레스를 처리한다. 즉, 동기 방식이다. 
    - 하지만 실제 코드에서 비동기가 필요한 상황들이 있다. 만약 무거운 작업이 있다면 이것을 비동기적으로 요청해두고 바로 다음 작업을 수행하면 훨씬 더 효율적인다. 
    - 자바스크립트는 **이벤트 루프** 덕분에 비동기 작업을 수행할 수 있다. 코드를 실행하며 비동기 작업은 "실행해!" 라는 명령을 담아 **어딘가**로 요청한다. 여기서 **어딘가**가 이벤트 루프이다. 덕분에 자바스크립트 엔진은 무거운 작업을 어딘가에 요청해두고, 동기적으로 바로 다음 코드를 실행할 수 있다. 이때 이벤트 루프에서 그 무거운 작업이 완료되면, 콜백 함수를 통해 후속 작업을 진행한다. 비동기 처리가 끝난 후 코드를 순차적으로 실행하기 위해 promise 함수를 사용하기도 한다.

### ORM이 무엇인가요? 단점은 없을까요?
- <span style="background-color: #EBFFDA">**ORM(Object Relational Mapping)이란?**</span>
  - ORM 은 객체와 데이터베이스의 관계를 매핑해주는 도구이다. 즉, 프로그래밍 언어의 객체와 관계형 데이터베이스의 데이터를 자동으로 매핑(연결)해주는 도구이다.
  - python에서 class 객체를 만들면, 이것이 Database의 table에 자동으로 매핑되는 것이다.

- <span style="background-color: #EBFFDA">**ORM을 사용하는 이유**</span>
  - 직관적인 코드 + 가독성
    - ORM을 사용하면, SQL Query 를 사용하지 않고 직관적인 코드(메소드)를 사용하여 데이터를 조작할 수 있다. 
    - 개발자가 기존에 개발하던 언어 그대로 객체 모델만 프로그래밍하면 된다.
    - SQL의 절차적이고 순차적인 접근이 아닌 객체 지향적인 접근으로 생산성이 증가한다. 
  - 재사용 및 유지보수 편리성 증가
    - ORM은 독립적으로 작성되고, 만든 객체들을 재사용할 수 있기 때문에 편리하다
  - DBMS에 대한 종속성이 줄어듦
    - 객체 간의 관계를 바탕으로 SQL을 자동으로 생성하기 때문에 RDBMS의 데이터 구조와 프로그래밍 언어의 객체지향 모델 사이의 간격을 좁힐 수 있다.
    - 프로그래머는 객체에 집중해서, DBMS를 교체하거나 보수할때도 적은 리스크와 시간이 소요된다.

- <span style="background-color: #EBFFDA">**ORM의 단점**</span>
  - ORM만을 사용해서 모든 것을 해결할 수 없다.
    - ORM은 매우 편리하지만, 데이터베이스를 설계할 때는 매우 신중하게 설계해야 한다. 또한 속도를 위해서 결국에는 SQL문을 사용해야 되는 경우가 생긴다.
  - 패러다임 불일치 
    |불일치|설명|
    |:---:|---|
    |세분성(Granularity)|경우에 따라서 데이터베이스에 있는 테이블 수보다 더 많은 클래스를 가진 모델이 생길 수 있다.|
    |상속성(Inheritance)|RDBMS는 객체지향 프로그래밍 언어의 특징인 상속 개념이 없다. |
    |일치(Identity)|RDBMS는 기본키(primary key)를 이용하여 동일성을 정의한다.<br> 그러나 자바는 객체 식별(a==b) 과 객체 동일성(a.equals(b)) 을 모두 정의한다.|
    |연관성(Associations)|객체지향 언어는 방향성이 있는 객체의 참조(reference)를 사용하여 연관성을 나타내지만 RDBMS는 방향성이 없는 외래키(foreign key)를 이용해서 나타낸다.<br> 그래서 객체 모델에서 양방향을 참조하려면 양쪽에 연관을 두 번 정의해야 한다.|
    |탐색(Navigation)|자바와 RDBMS에서 객체를 접근하는 방법이 근본적으로 다르다. <br>자바는 그래프형태로 하나의 연결에서 다른 연결로 이동하며 탐색하지만 RDBMS는 일반적으로 SQL문을 최소화하고 JOIN 을 통해 여러 엔티티를 로드하고 원하는 대상 엔티티를 선택하는 방식으로 탐색한다.|


### RDB와 NoSQL의 차이가 무엇인가요? 왜 각자 그런 형태를 선택했을까요?

### DB의 인덱스의 개념에 대해 설명해주세요.

### DB의 트랜잭션과, ACID 원칙에 대해 설명하고, Lock에 대해 설명해주세요.

### 동시성과 병렬성의 차이가 무엇인가요? 멀티코어 프로그래밍 관점에서 설명해주세요.



## Reference
- https://aws.amazon.com/ko/compare/the-difference-between-containers-and-virtual-machines/
- https://cloudmt.co.kr/?p=3927
- https://dining-developer.tistory.com/21
- https://dev.to/thecodearcher/what-really-is-the-difference-between-session-and-token-based-authentication-2o39
- https://joooing.tistory.com/entry/%EB%8F%99%EA%B8%B0%EB%B9%84%EB%8F%99%EA%B8%B0-%EB%B8%94%EB%A1%9C%ED%82%B9%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9
- https://www.youtube.com/watch?v=IdpkfygWIMk
- https://gobae.tistory.com/100